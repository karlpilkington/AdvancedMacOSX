// SnarfOperation.m -- Implementation of an image downloading operation.

#import "SnarfOperation.h"

// Republish our read-only properties so we they are mutable for us.

@interface SnarfOperation ()

@property (readwrite) BOOL isExecuting;
@property (readwrite) BOOL isFinished;
@property (readwrite) BOOL wasSuccessful;
@property (nonatomic, assign, readwrite) NSImage *image;

@end // SnarfOperation


@implementation SnarfOperation

// Generate the accessors.
@synthesize isExecuting = _isExecuting;
@synthesize isFinished = _isFinished;
@synthesize wasSuccessful = _wasSuccessful;

@synthesize url = _url;
@synthesize image = _image;


// NSOperation disengages the KVO machinery for the finished and
// executing properties.  Re-engage the automatic machinery to do
// automagic KVO notifications when we change the values.

+ (BOOL) automaticallyNotifiesObserversForKey: (NSString *) key {

    // We're lazy, so let Cocoa do all the KVO grooviness for these
    // attributes.
    if ([key isEqualToString: @"isFinished"]
        || [key isEqualToString:@"isExecuting"]) {
        return YES;

    } else {
        // Otherwise do whatever NSOperation does.
        return [super automaticallyNotifiesObserversForKey: key];
    }

} // automaticallyNotifiesObserversForKey


// Set up a new operation to download an image from this URL.
// Dont actually start the download until someone tells us to -start.

- (id) initWithURL: (NSURL *) u {
    if ((self = [super init])) {
        _url = u;
    }

    return self;

} // initWithURL


// Time to get to work.  Make a new URL Request and Connection and start
// them running.

- (void) start {
    // Avoid unnecessary work.
    if (self.isCancelled) return;

    // In 10.6, all NSOperations are run on a thread.  NSURLConnection is 
    // runloop based, and the thread that we are initially kick off the connect
    // with might disappear, courtesy of GCD, before we finish the loading
    // operation.
    // So we force the run of ourselves on the main thread, which we know will
    // stick around, and glom on to its runloop to run NSURLConnection.

    if (![NSThread isMainThread]) {
        [self performSelectorOnMainThread: @selector(start)
              withObject: nil
              waitUntilDone: NO];
        return;
    }

    // Since we've started, we're executing.
    self.isExecuting = YES;

    // Build a request to fetch the image.  The default URLs in the
    // sample are at borkware.com, and this will let us know how much
    // traffic is being generated by this sample.
    // Cookies are also turned off to reduce load on the server.
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL: self.url];
    [request setValue: @"ImageSnarfer"  forHTTPHeaderField: @"User-Agent"];
    [request setHTTPShouldHandleCookies: NO];
    [request setCachePolicy: NSURLRequestReloadIgnoringLocalCacheData];

    // _imageData holds the data that comes down from the internet.
    _imageData = [NSMutableData data];

    _connection = [[NSURLConnection alloc] initWithRequest: request
                                           delegate: self];
    [_connection start];

} // start


// We're done.  Whomever calls us will set wasSuccessful, and we do
// any connection cleanup, and set our isExecuting and isFinished
// attributes to signal KVO observers our new state.

- (void) done {
    _connection = nil;

    self.isExecuting = NO;
    self.isFinished = YES;

} // done


// We are pretty easy to cancel.  Stop the url downloading, release our
// reference to the image data, and notify KVO observers via -done.
- (void) cancel {
    [_connection cancel];
    
    _imageData = nil;

    [self done];
    [super cancel];

} // cancel


// Return an image constructed from the downloaded data.  Return nil if
// the data loading was not successful or there was a problem turning it
// into an image.
- (NSImage *) image {
    if (self.wasSuccessful && _image == nil) {
        // Use the property so that someone interested in the image via
        // KVO will get a notification.
        _image = [[NSImage alloc] initWithData: _imageData];
        _imageData = nil; // Don't need to hang on to it anymore
    }

    return _image;

} // image


// Properties will handle making an isFinished and isExecuting, and making
// everything KVC compliant.

// --------------------------------------------------
// NSURLConnection delegate methods.

- (void) connection: (NSURLConnection *) c
 didReceiveResponse: (NSURLResponse *) response {

    // This can be called multple times (like for redirection),
    // so toss any accumulated data.

    [_imageData setLength: 0];

} // didReceiveResponse


- (void) connection: (NSURLConnection *) c
     didReceiveData: (NSData *) data {
    
    [_imageData appendData: data];

} // didReceiveData


- (void) connection: (NSURLConnection *) c
   didFailWithError: (NSError *) error {

    _imageData = nil;

    self.wasSuccessful = NO;
    [self done];

} // didFailWithError


- (void) connectionDidFinishLoading: (NSURLConnection *) c {

    self.wasSuccessful = YES;
    [self done];

} // connectionDidFinishLoading

@end // SnarfOperation
