// SnarfOperation.m -- Implementation of an image downloading operation.

#import "SnarfOperation.h"

// Republish our read-only properties so we they are mutable for us.
@interface SnarfOperation ()

@property (readwrite) BOOL isExecuting;
@property (readwrite) BOOL isFinished;
@property (readwrite) BOOL wasSuccessful;
@property (assign, readwrite) NSImage *image;

@end // SnarfOperation


@implementation SnarfOperation

// Generate the accessors.
@synthesize isExecuting;
@synthesize isFinished;
@synthesize wasSuccessful;

@synthesize url;
@synthesize image;


// NSOperation disengages the KVO machinery for the finished and
// executing properties.  Re-engage the automatic machinery to do
// automagic KVO notifications when we change the values.

+ (BOOL) automaticallyNotifiesObserversForKey: (NSString *) key {

    // We're lazy, so let Cocoa do all the KVO grooviness for these
    // attributes.
    if ([key isEqualToString: @"isFinished"]
        || [key isEqualToString:@"isExecuting"]) {
        return (YES);

    } else {
        // Otherwise do whatever NSOperation does.
        return ([super automaticallyNotifiesObserversForKey: key]);
    }

} // automaticallyNotifiesObserversForKey


// Set up a new operation to download an image from this URL.
// Dont actually start the download until someone tells us to -start.

- (id) initWithURL: (NSURL *) u {
    if (self = [super init]) {
        url = u;
    }

    return (self);

} // initWithURL


// Time to get to work.  Make a new URL Request and Connection and start
// them running.

- (void) start {

    // Avoid unnecessary work.
    if (self.isCancelled) return;

    // Since we've started, we're executing.
    self.isExecuting = YES;

    // Build a request to fetch the image.  The default URLs in the
    // sample are at borkware.com, and this will let us know how much
    // traffic is being generated by this sample :-)
    // Cookies are also turned off to reduce load on the server.
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL: url];
    [request setValue: @"ImageSnarfer"
             forHTTPHeaderField: @"User-Agent"];
    [request setHTTPShouldHandleCookies: NO];
    [request setCachePolicy: NSURLRequestReloadIgnoringLocalCacheData];

    // imageData is where data that comes down from the internet will
    // be put.
    imageData = [NSMutableData data];

    // Start the connection.
#define LOADING_EXERCISE 0
#if LOADING_EXERCISE
    connection = [[NSURLConnection alloc]
                     initWithRequest: request
                     delegate: self
                     startImmediately: NO];
    [connection scheduleInRunLoop: [NSRunLoop currentRunLoop]
                forMode: NSRunLoopCommonModes];

    [connection start];
#else
    connection = [[NSURLConnection alloc]
                     initWithRequest: request
                     delegate: self];
#endif
    
} // start


// We're using asynchronous URL loading, so we're 'concurrent'.

- (BOOL) isConcurrent {
    return (YES);
} // isConcurrent


// We're done.  Whomever calls us will set wasSuccessful, and we do
// any connection cleanup, and set our isExecuting and isFinished
// attributes to signal KVO observers our new state.

- (void) done {
    connection = nil;

    self.isExecuting = NO;
    self.isFinished = YES;

} // done


- (void) cancel {
    [connection cancel];
    
    imageData = nil;

    [self done];
    [super cancel];

} // cancel


// Return an image constructed from the downloaded data.  Return nil if
// the data loading was not successful or there was a problem turning it
// into an image.

- (NSImage *) image {
    if (wasSuccessful && image == nil) {
        // Use the property so that someone interested in the image via
        // KVO will get a notification.
        self.image = [[NSImage alloc] initWithData: imageData];
        imageData = nil; // Don't need to hang on to it anymore
    }

    return image;

} // image


// Properties will handle making an isFinished and isExecuting, and making
// everything KVC compliant.

// --------------------------------------------------
// NSURLConnection delegate methods.

- (void) connection: (NSURLConnection *) c
 didReceiveResponse: (NSURLResponse *) response {

    // This can be called multple times (like for redirection),
    // so toss any data we might have accumulated so far.

    [imageData setLength: 0];

} // didReceiveResponse


- (void) connection: (NSURLConnection *) c
     didReceiveData: (NSData *) data {
    
    [imageData appendData: data];

} // didReceiveData


- (void) connection: (NSURLConnection *) c
   didFailWithError: (NSError *) error {

    imageData = nil;

    self.wasSuccessful = NO;
    [self done];

} // didFailWithError


- (void) connectionDidFinishLoading: (NSURLConnection *) c {

    self.wasSuccessful = YES;
    [self done];

} // connectionDidFinishLoading
    

@end // SnarfOperation
